---
title: "Error Checking - Other Methods"
pre: "15.5 "
weight: 25
date: 2020-10-16T00:27:26-05:00
---

{{< youtube Xe_5Rz_Hcd8 >}}


#### Resources
* [Slides](/1-cc110/15-compression-error-checking/slides/21-Compression-Error-Checking.pdf)

#### Video Script

Let's go over a couple other error checking methods that you might run across, we're not going to go into these in too much detail because they are kind of complex at this level. But we'll give you an idea of what's out there, just so you can say you've seen it. One interesting example is the cyclic redundancy check or CRC. With CRC will have some sort of binary value. And we'll use a particular checksum to verify it. So we'll start with this binary value on a checksum. And we will compute the XOR of the checksum, and that binary value. So we start with 1010. And we XOR that with 1011. So we'll get 1. And this works a lot like long division, we just keep working down the value until we get left with something that is smaller than our checksum. And so with this input 101000001001, we would send along these three bits 011 as our checksum. And then once we've received it, we can do this same division again, and make sure that we get the same checksum to know that the error hasn't been introduced in our code. 

Another method of error checking is hash codes. And hash codes are really complex. But they basically are a one way algorithm to take any piece of data and convert it into a single value. So for example, we would choose some sort of a hash base like 2 or 10, or 37. And then if we have a whole bunch of numbers, we would calculate the hash as the first number times our base to the value in plus the second number times the base to the power n minus one, and so on, and so forth. So if we have the word 456, if our base is 10, obviously, our hash should be 456. If our base is 100, we get 4056. If our bases, just five, it would be 126. But if we choose some interesting other numbers, we would get different hash codes. Later on, if you start taking programming courses, one of the data structures you'll learn about is a hash table, sometimes known as a dictionary or a hash map. And to do that, what it does is it takes a piece of data and it computes the hash of that data, and then uses that to store the data in a unique way so that it can be quickly retrieved. But we can also use those hashes to verify data. 

Another really common use of hashes would be password store. For example, md5 is a commonly used pass password hashing algorithm, or at least it was it's been cracked since then. But you could take any text and calculate the md5 hash of that text and store that number. Then if anyone tried to input a password, you would simply take their password, re-compute the hash. And if it created the same hash as the actual password, then you know that that user inputed the create the correct password, and you could allow them access. Here's another quick example of hash codes, just showing what it would look like for some other input data. 

Another form of error checking you might run into is called a hamming code. And a hamming code is kind of complex. But what it does is it takes the data bits that you want to send and it calculates what are called parity bits for those data bits. A parity bit is basically a bit that's designed to make all of those data bits plus the parity bit come up to an even number of ones. So if we want to send the data in bits, 3,5,6, and 7, for example, we want to send 0100, we calculate these three Hamming parity bits. The first one is 3,5,7. So we look at 3,5,7, there's only a single one there. So that parity bit would be a one, the bits 3, 6, and 7 would be 3,6,7. There's no one so we put a zero there. And then for 5,6,7, there's a single one, so we need to add one more one to get to an even number of ones. Then to construct the actual hamming code, we have our first parity bit, our second parity bit, so one, zero, then we have our first data bit zero, then our last parity bit one, and then the last three bits of our data Five, six, and seven. It's a little complex. But the concept behind Hamming codes is to create data words that are so far apart from each other that a single bit error, you can almost just round it to the closest binary value that makes sense for the hamming code that you're using, and use that as your way to solve different errors. In this module, we've covered a lot of different ways that you can compress and do error checking on data that you send and receive or data that you store in your computer's while a lot of this can be kind of complex and math heavy. 

I'm hoping this opens your eyes a little bit to some of the things that go on behind the scenes on your computer that you might be aware of, but really didn't understand how they work. We deal with things like zip files and JPEG images all the time. And those are all examples of compression. Error checking is a little bit more behind the scenes, but it's really the backbone of how we can send and receive data across the internet using these unreliable connections and packets that might be dropped and still be able to recover and understand the data that we receive on the other side.